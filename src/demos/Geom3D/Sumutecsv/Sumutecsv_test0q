#!/bin/sh
# Sumutecsv_test0q - for program SUMUTECSV
# Author: Andre Latour, Feb 2022
#
  echo "----------------------------------------------------------------------------"
  echo "---  This test creates some traces (using sunull).                          "
  echo "---  Then it sets every sample amplitude in those traces to 100.            "
  echo "---  Then it sets the cdp number(s) (starts at 1, increments by 1)          "
  echo "---  Then it sets the offset to 600 for all traces.                         "
  echo "---  Then it applies a 3D mute to those traces and displays it.             "
  echo "---  2 cases are made and displayed (note title on bottom of displays).     "
  echo "---  These 2 cases give nice displays to help understand what is going on.  "
  echo "---  Some of these cases also require special handling code in sumutecsv    "
  echo "---  os it is desirable to have specific tests for them.                    "
  echo "---    1 mute function only is specified.                                   "
  echo "---    2 mute functions specified on just 1 inline (with extrapolation)     "
  echo "---                                                                         "
  echo "---  Notes: Only 5 inlines worth of cdps are created (1 trace per cdp).     "
  echo "---         For ease of initial understanding of the displays,              "
  echo "---         extrapolation is enabled in both directions (not the default).  "
  echo "----------------------------------------------------------------------------"
#
# I know the 3d grid is 121 by 23 cells. Make 605 traces (5 inlines of 121).   
# Make cdp numbers starting at 1, incrementing by 1. Set all offsets to 600.
#
  sunull nt=1500 ntr=605 dt=0.004 >tnullq0.su
  sumath <tnullq0.su op=add a=100 >tnullq0a.su
  sushw <tnullq0a.su >tnullq0acdp.su key=cdp a=1 b=1
  sushw <tnullq0acdp.su >tnullq0acdpoff.su key=offset a=600 b=0
#
# sumutecsv <tnull0acdpoff.su >tnull0acdpoffmute1.su rfile=kEFG.csv mode=0 extrapi=1 extrapc=1 \
  sumutecsv <tnullq0acdpoff.su >tnullq0acdpoffmute1.su mode=0 \
        qin=t0q.csv \
#
  suxwigb <tnullq0acdpoffmute1.su key=cdp xcur=0.5 title='one mute function' & 
#
# The next 2 programs subtract the results of the command line input test Sunmocsv_realistic2 
# and this test of qin file input (which has the same velocity function values).
# The result should be all zeroes of course.                                      
#
  suop2 tnull0acdpoffmute1.su tnullq0acdpoffmute1.su op=diff >tnullq0fake.su
#
  sumax <tnullq0fake.su
#
  sumutecsv <tnullq0acdpoff.su >tnullq0acdpoffmute2.su rfile=kEFG.csv mode=0 extrapi=1 \
        qin=t1q.csv \
#
  suxwigb <tnullq0acdpoffmute2.su key=cdp xcur=0.5 title="two mute functions on 1 inline (with extrapolation)" & 
#
  suop2 tnull0acdpoffmute2.su tnullq0acdpoffmute2.su op=diff >tnullq1fake.su
#
  sumax <tnullq1fake.su
#
# The suop2 and sumax concept above can be used as a (limited) unit test. 
# Before adding some option in the code, run all tests and preserve the outputs.
# Then make your code changes, and rerun all tests. Then use suop2,sumax
# to compare the old/new output files. The result should be 0,0 unless 
# you intended otherwise.  
#   However, do not presume this would be useful in general.
#   That is, if you uploaded the output files into GITHUB (or whatever) then,
#   later, you could run suop2,sumax tests comparing the old GITHUB files     
#   to files newly generated by these tests. 
#        You could then automate this into unit-tests.                                                     
#   But that is not likely to be a generally useful thing for Seismic Unix.
#   The trouble comes down to the fact the seismic data is floating point.
#   As hardware/compiler/optimizers develop, floating point results always 
#   change slightly, especially for seismic sample values themselves, but 
#   also for some header values (for instance: statics). For any change
#   of hardware/compiler/optimizer the difference after sumax is not 0.
#   Having worked a long time for a major corporation that developed an 
#   industry-leading seismic processing system, checking these kinds of
#   unit-tests requires large effort, manpower, and organizational structure
#   that Seismic Unix will never have available.
